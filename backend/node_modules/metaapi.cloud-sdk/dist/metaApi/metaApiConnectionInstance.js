"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return MetaApiConnectionInstance;
    }
});
const _metaApiWebsocketclient = /*#__PURE__*/ _interop_require_default(require("../clients/metaApi/metaApiWebsocket.client"));
const _logger = /*#__PURE__*/ _interop_require_default(require("../logger"));
const _randomstring = /*#__PURE__*/ _interop_require_default(require("randomstring"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let MetaApiConnectionInstance = class MetaApiConnectionInstance {
    /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @return {Promise} promise resolving when the connection is opened
   */ async connect() {
        this._opened = true;
    }
    /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   */ async close() {
        this._opened = false;
        this._closed = true;
    }
    /**
   * Common trade options
   * @typedef {Object} TradeOptions
   * @property {String} [comment] optional order comment. The sum of the line lengths of the comment and the
   * clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [clientId] optional client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {Number} [magic] optional magic (expert id) number. If not set default value specified in account entity
   * will be used.
   * @property {Number} [slippage] optional slippage in points. Should be greater or equal to zero. In not set,
   * default value specified in account entity will be used. Slippage is ignored if execution mode set to
   * SYMBOL_TRADE_EXECUTION_MARKET in symbol specification. Not used for close by orders.
   */ /**
   * Market trade options
   * @typedef {TradeOptions} MarketTradeOptions
   * @property {Array<String>} [fillingModes] optional allowed filling modes in the order of priority. Default is to
   * allow all filling modes and prefer ORDER_FILLING_FOK over ORDER_FILLING_IOC. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_filling for extra
   * explanation
   */ /**
   * Market trade options
   * @typedef {MarketTradeOptions} CreateMarketTradeOptions
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defines the base price to calculate SL/TP relative to for pending order
   * requests. Default is CURRENT_PRICE, one of CURRENT_PRICE
   */ /**
   * Pending order trade options
   * @typedef {TradeOptions} PendingTradeOptions
   * @property {ExpirationOptions} [expiration] optional pending order expiration settings. See Pending order expiration
   * settings section
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defined the base price to calculate SL/TP relative to for *_MODIFY and pending
   * order requests. STOP_PRICE means the SL/TP is relative to previous SL/TP value. Default is OPEN_PRICE, one of
   * CURRENT_PRICE, OPEN_PRICE
   * @property {String} [openPriceUnits] open price units. ABSOLUTE_PRICE means the that the value of openPrice field
   * is a final open price value. RELATIVE* means that the openPrice field value contains relative open price expressed
   * either in price, points, pips, account currency or balance percentage. Default is ABSOLUTE_PRICE. One of
   * ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   */ /**
   * Options for creating a stop limit pending order
   * @typedef {PendingTradeOptions} StopLimitPendingTradeOptions
   * @property {String} [openPriceBase] defined the base price to calculate open price relative to for ORDER_MODIFY
   * and pending order requests. Default is CURRENT_PRICE for pending orders or STOP_LIMIT_PRICE for stop limit orders.
   * One of CURRENT_PRICE, OPEN_PRICE, STOP_LIMIT_PRICE
   * @property {String} [stopLimitPriceUnits] stop limit price units. ABSOLUTE_PRICE means the that the value of
   * stopLimitPrice field is a final stop limit price value. RELATIVE* means that the stopLimitPrice field value
   * contains relative stop limit price expressed either in price, points, pips, account currency or balance percentage.
   * Default is ABSOLUTE_PRICE. One of ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY,
   * RELATIVE_BALANCE_PERCENTAGE
   */ /**
   * Options for modifying orders
   * @typedef {Object} ModifyOrderOptions
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defined the base price to calculate SL/TP relative to for *_MODIFY and pending
   * order requests. STOP_PRICE means the SL/TP is relative to previous SL/TP value. Default is OPEN_PRICE, one of
   * CURRENT_PRICE, OPEN_PRICE, STOP_PRICE
   * @property {String} [openPriceUnits] open price units. ABSOLUTE_PRICE means the that the value of openPrice field
   * is a final open price value. RELATIVE* means that the openPrice field value contains relative open price expressed
   * either in price, points, pips, account currency or balance percentage. Default is ABSOLUTE_PRICE. One of
   * ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   * @property {String} [openPriceBase] defined the base price to calculate open price relative to for ORDER_MODIFY
   * and pending order requests. Default is CURRENT_PRICE for pending orders or STOP_LIMIT_PRICE for stop limit orders.
   * One of CURRENT_PRICE, OPEN_PRICE, STOP_LIMIT_PRICE
   * @property {String} [stopLimitPriceUnits] stop limit price units. ABSOLUTE_PRICE means the that the value of
   * stopLimitPrice field is a final stop limit price value. RELATIVE* means that the stopLimitPrice field value
   * contains relative stop limit price expressed either in price, points, pips, account currency or balance percentage.
   * Default is ABSOLUTE_PRICE. One of ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY,
   * RELATIVE_BALANCE_PERCENTAGE
   * @property {String} [stopLimitPriceBase] Defined the base price to calculate stop limit price relative to for
   * ORDER_MODIFY requests. One of CURRENT_PRICE, STOP_LIMIT_PRICE
   */ /**
   * Pending order expiration settings
   * @typedef {Object} ExpirationOptions
   * @property {String} type pending order expiration type. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_time for the list of
   * possible options. MetaTrader4 platform supports only ORDER_TIME_SPECIFIED expiration type. One of ORDER_TIME_GTC,
   * ORDER_TIME_DAY, ORDER_TIME_SPECIFIED, ORDER_TIME_SPECIFIED_DAY
   * @property {Date} [time] optional pending order expiration time. Ignored if expiration type is not one of
   * ORDER_TIME_DAY or ORDER_TIME_SPECIFIED
   */ /**
   * Stop options
   * @typedef {Object} StopOptions
   * @property {number} value stop (SL or TP) value
   * @property {string} units stop units. ABSOLUTE_PRICE means the that the value of value field is a final stop value.
   * RELATIVE_* means that the value field value contains relative stop expressed either in price, points, pips, account
   * currency or balance percentage. Default is ABSOLUTE_PRICE. Allowed values are ABSOLUTE_PRICE, RELATIVE_PRICE,
   * RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   */ /**
   * Creates a market buy order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {CreateMarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createMarketBuyOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_BUY",
            symbol,
            volume
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a market sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {CreateMarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createMarketSellOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_SELL",
            symbol,
            volume
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a limit buy order
   * @param {String} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createLimitBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_BUY_LIMIT",
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a limit sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createLimitSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_SELL_LIMIT",
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop buy order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_BUY_STOP",
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_SELL_STOP",
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop limit buy order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {StopLimitPendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopLimitBuyOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_BUY_STOP_LIMIT",
            symbol,
            volume,
            openPrice,
            stopLimitPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop limit sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {StopLimitPendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopLimitSellOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_TYPE_SELL_STOP_LIMIT",
            symbol,
            volume,
            openPrice,
            stopLimitPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Modifies a position
   * @param {string} positionId position id to modify
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @param {String} [stopPriceBase] defines the base price to calculate SL relative to for POSITION_MODIFY and
   * pending order requests. Default is OPEN_PRICE. One of CURRENT_PRICE, OPEN_PRICE, STOP_PRICE
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ modifyPosition(positionId, stopLoss, takeProfit, trailingStopLoss, stopPriceBase) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "POSITION_MODIFY",
            positionId,
            trailingStopLoss,
            stopPriceBase
        }, this._generateStopOptions(stopLoss, takeProfit)));
    }
    /**
   * Partially closes a position
   * @param {string} positionId position id to modify
   * @param {number} volume volume to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closePositionPartially(positionId, volume, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "POSITION_PARTIAL",
            positionId,
            volume
        }, options || {}));
    }
    /**
   * Fully closes a position
   * @param {string} positionId position id to modify
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closePosition(positionId, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "POSITION_CLOSE_ID",
            positionId
        }, options || {}));
    }
    /**
   * Fully closes a position
   * @param {string} positionId position id to close by opposite position
   * @param {string} oppositePositionId opposite position id to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closeBy(positionId, oppositePositionId, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "POSITION_CLOSE_BY",
            positionId,
            closeByPositionId: oppositePositionId
        }, options || {}));
    }
    /**
   * Closes positions by a symbol
   * @param {string} symbol symbol to trade
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closePositionsBySymbol(symbol, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "POSITIONS_CLOSE_SYMBOL",
            symbol
        }, options || {}));
    }
    /**
   * Modifies a pending order
   * @param {string} orderId order id (ticket number)
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {ModifyOrderOptions} [options] optional modify order options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ modifyOrder(orderId, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: "ORDER_MODIFY",
            orderId,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Cancels order
   * @param {string} orderId order id (ticket number)
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ cancelOrder(orderId) {
        this._checkIsConnectionActive();
        return this._trade({
            actionType: "ORDER_CANCEL",
            orderId
        });
    }
    _trade(request) {
        return this._websocketClient.trade(this._metaApiConnection.account.id, request, this._metaApiConnection.application, this._metaApiConnection.account.reliability);
    }
    /**
   * Calculates margin required to open a trade on the specified trading account
   * @param {MarginOrder} order order to calculate margin for
   * @returns {Promise<Margin>} promise resolving with margin calculation result
   */ calculateMargin(order) {
        this._checkIsConnectionActive();
        return this._websocketClient.calculateMargin(this._metaApiConnection.account.id, this._metaApiConnection.application, this._metaApiConnection.account.reliability, order);
    }
    /**
   * Forces refresh and retrieves latest quotes for a subset of symbols the terminal is subscribed to. Note, that this
   * method works separately from the streamed data (for streaming connection), so the response may be obsolete already,
   * if some updates happen during the request
   * @param {string[]} symbols quote symbols to refresh
   * @returns {Promise<RefreshedQuotes>} quotes that was actually updated (a subset of specified symbols), and some of
   * basic account information
   */ refreshSymbolQuotes(symbols) {
        this._checkIsConnectionActive();
        return this._websocketClient.refreshSymbolQuotes(this._metaApiConnection.account.id, symbols);
    }
    /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */ get account() {
        return this._metaApiConnection.account;
    }
    /**
   * Returns connection instance id
   * @return {String} connection instance id
   */ get instanceId() {
        return this._instanceId;
    }
    _generateStopOptions(stopLoss, takeProfit) {
        let trade = {};
        if (typeof stopLoss === "number") {
            trade.stopLoss = stopLoss;
        } else if (stopLoss) {
            trade.stopLoss = stopLoss.value;
            trade.stopLossUnits = stopLoss.units;
        }
        if (typeof takeProfit === "number") {
            trade.takeProfit = takeProfit;
        } else if (takeProfit) {
            trade.takeProfit = takeProfit.value;
            trade.takeProfitUnits = takeProfit.units;
        }
        return trade;
    }
    _checkIsConnectionActive() {
        if (!this._opened) {
            throw new Error("This connection has not been initialized yet, please invoke await connection.connect()");
        }
        if (this._closed) {
            throw new Error("This connection has been closed, please create a new connection");
        }
    }
    /**
   * Constructs MetaApi MetaTrader Api connection instance
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {MetaApiConnection} metaApiConnection MetaApi connection to use
   */ constructor(websocketClient, metaApiConnection){
        this._websocketClient = websocketClient;
        this._metaApiConnection = metaApiConnection;
        this._instanceId = _randomstring.default.generate(32);
        this._logger = _logger.default.getLogger("MetaApiConnectionInstance");
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBNZXRhQXBpV2Vic29ja2V0Q2xpZW50IGZyb20gJy4uL2NsaWVudHMvbWV0YUFwaS9tZXRhQXBpV2Vic29ja2V0LmNsaWVudCc7XG5pbXBvcnQgTG9nZ2VyTWFuYWdlciBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHJhbmRvbXN0cmluZyBmcm9tICdyYW5kb21zdHJpbmcnO1xuXG4vKipcbiAqIEV4cG9zZXMgTWV0YUFwaSBNZXRhVHJhZGVyIEFQSSBjb25uZWN0aW9uIGluc3RhbmNlIHRvIGNvbnN1bWVyc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBNZXRhQXBpIE1ldGFUcmFkZXIgQXBpIGNvbm5lY3Rpb24gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50fSB3ZWJzb2NrZXRDbGllbnQgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50XG4gICAqIEBwYXJhbSB7TWV0YUFwaUNvbm5lY3Rpb259IG1ldGFBcGlDb25uZWN0aW9uIE1ldGFBcGkgY29ubmVjdGlvbiB0byB1c2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdlYnNvY2tldENsaWVudCwgbWV0YUFwaUNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQgPSB3ZWJzb2NrZXRDbGllbnQ7XG4gICAgdGhpcy5fbWV0YUFwaUNvbm5lY3Rpb24gPSBtZXRhQXBpQ29ubmVjdGlvbjtcbiAgICB0aGlzLl9pbnN0YW5jZUlkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignTWV0YUFwaUNvbm5lY3Rpb25JbnN0YW5jZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBjb25uZWN0aW9uLiBDYW4gb25seSBiZSBjYWxsZWQgdGhlIGZpcnN0IHRpbWUsIG5leHQgY2FsbHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5lZFxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICB0aGlzLl9vcGVuZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi4gVGhlIGluc3RhbmNlIG9mIHRoZSBjbGFzcyBzaG91bGQgbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXIgdGhpcyBtZXRob2QgaXMgaW52b2tlZC5cbiAgICovXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHRoaXMuX29wZW5lZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDb21tb24gdHJhZGUgb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb21tZW50XSBvcHRpb25hbCBvcmRlciBjb21tZW50LiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlIGNvbW1lbnQgYW5kIHRoZVxuICAgKiBjbGllbnRJZCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NsaWVudElkXSBvcHRpb25hbCBjbGllbnQtYXNzaWduZWQgaWQuIFRoZSBpZCB2YWx1ZSBjYW4gYmUgYXNzaWduZWQgd2hlbiBzdWJtaXR0aW5nIGEgdHJhZGUgYW5kXG4gICAqIHdpbGwgYmUgcHJlc2VudCBvbiBwb3NpdGlvbiwgaGlzdG9yeSBvcmRlcnMgYW5kIGhpc3RvcnkgZGVhbHMgcmVsYXRlZCB0byB0aGUgdHJhZGUuIFlvdSBjYW4gdXNlIHRoaXMgZmllbGQgdG8gYmluZFxuICAgKiB5b3VyIHRyYWRlcyB0byBvYmplY3RzIGluIHlvdXIgYXBwbGljYXRpb24gYW5kIHRoZW4gdHJhY2sgdHJhZGUgcHJvZ3Jlc3MuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGVcbiAgICogY29tbWVudCBhbmQgdGhlIGNsaWVudElkIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWFnaWNdIG9wdGlvbmFsIG1hZ2ljIChleHBlcnQgaWQpIG51bWJlci4gSWYgbm90IHNldCBkZWZhdWx0IHZhbHVlIHNwZWNpZmllZCBpbiBhY2NvdW50IGVudGl0eVxuICAgKiB3aWxsIGJlIHVzZWQuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2xpcHBhZ2VdIG9wdGlvbmFsIHNsaXBwYWdlIGluIHBvaW50cy4gU2hvdWxkIGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gemVyby4gSW4gbm90IHNldCxcbiAgICogZGVmYXVsdCB2YWx1ZSBzcGVjaWZpZWQgaW4gYWNjb3VudCBlbnRpdHkgd2lsbCBiZSB1c2VkLiBTbGlwcGFnZSBpcyBpZ25vcmVkIGlmIGV4ZWN1dGlvbiBtb2RlIHNldCB0b1xuICAgKiBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX01BUktFVCBpbiBzeW1ib2wgc3BlY2lmaWNhdGlvbi4gTm90IHVzZWQgZm9yIGNsb3NlIGJ5IG9yZGVycy5cbiAgICovXG5cbiAgLyoqXG4gICAqIE1hcmtldCB0cmFkZSBvcHRpb25zXG4gICAqIEB0eXBlZGVmIHtUcmFkZU9wdGlvbnN9IE1hcmtldFRyYWRlT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge0FycmF5PFN0cmluZz59IFtmaWxsaW5nTW9kZXNdIG9wdGlvbmFsIGFsbG93ZWQgZmlsbGluZyBtb2RlcyBpbiB0aGUgb3JkZXIgb2YgcHJpb3JpdHkuIERlZmF1bHQgaXMgdG9cbiAgICogYWxsb3cgYWxsIGZpbGxpbmcgbW9kZXMgYW5kIHByZWZlciBPUkRFUl9GSUxMSU5HX0ZPSyBvdmVyIE9SREVSX0ZJTExJTkdfSU9DLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl90eXBlX2ZpbGxpbmcgZm9yIGV4dHJhXG4gICAqIGV4cGxhbmF0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNYXJrZXQgdHJhZGUgb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7TWFya2V0VHJhZGVPcHRpb25zfSBDcmVhdGVNYXJrZXRUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtUcmFpbGluZ1N0b3BMb3NzfSBbdHJhaWxpbmdTdG9wTG9zc10gZGlzdGFuY2UgdHJhaWxpbmcgc3RvcCBsb3NzIGNvbmZpZ3VyYXRpb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzdG9wUHJpY2VCYXNlXSBkZWZpbmVzIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBTTC9UUCByZWxhdGl2ZSB0byBmb3IgcGVuZGluZyBvcmRlclxuICAgKiByZXF1ZXN0cy4gRGVmYXVsdCBpcyBDVVJSRU5UX1BSSUNFLCBvbmUgb2YgQ1VSUkVOVF9QUklDRVxuICAgKi9cblxuICAvKipcbiAgICogUGVuZGluZyBvcmRlciB0cmFkZSBvcHRpb25zXG4gICAqIEB0eXBlZGVmIHtUcmFkZU9wdGlvbnN9IFBlbmRpbmdUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtFeHBpcmF0aW9uT3B0aW9uc30gW2V4cGlyYXRpb25dIG9wdGlvbmFsIHBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvbiBzZXR0aW5ncy4gU2VlIFBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvblxuICAgKiBzZXR0aW5ncyBzZWN0aW9uXG4gICAqIEBwcm9wZXJ0eSB7VHJhaWxpbmdTdG9wTG9zc30gW3RyYWlsaW5nU3RvcExvc3NdIGRpc3RhbmNlIHRyYWlsaW5nIHN0b3AgbG9zcyBjb25maWd1cmF0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcFByaWNlQmFzZV0gZGVmaW5lZCB0aGUgYmFzZSBwcmljZSB0byBjYWxjdWxhdGUgU0wvVFAgcmVsYXRpdmUgdG8gZm9yICpfTU9ESUZZIGFuZCBwZW5kaW5nXG4gICAqIG9yZGVyIHJlcXVlc3RzLiBTVE9QX1BSSUNFIG1lYW5zIHRoZSBTTC9UUCBpcyByZWxhdGl2ZSB0byBwcmV2aW91cyBTTC9UUCB2YWx1ZS4gRGVmYXVsdCBpcyBPUEVOX1BSSUNFLCBvbmUgb2ZcbiAgICogQ1VSUkVOVF9QUklDRSwgT1BFTl9QUklDRVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW29wZW5QcmljZVVuaXRzXSBvcGVuIHByaWNlIHVuaXRzLiBBQlNPTFVURV9QUklDRSBtZWFucyB0aGUgdGhhdCB0aGUgdmFsdWUgb2Ygb3BlblByaWNlIGZpZWxkXG4gICAqIGlzIGEgZmluYWwgb3BlbiBwcmljZSB2YWx1ZS4gUkVMQVRJVkUqIG1lYW5zIHRoYXQgdGhlIG9wZW5QcmljZSBmaWVsZCB2YWx1ZSBjb250YWlucyByZWxhdGl2ZSBvcGVuIHByaWNlIGV4cHJlc3NlZFxuICAgKiBlaXRoZXIgaW4gcHJpY2UsIHBvaW50cywgcGlwcywgYWNjb3VudCBjdXJyZW5jeSBvciBiYWxhbmNlIHBlcmNlbnRhZ2UuIERlZmF1bHQgaXMgQUJTT0xVVEVfUFJJQ0UuIE9uZSBvZlxuICAgKiBBQlNPTFVURV9QUklDRSwgUkVMQVRJVkVfUFJJQ0UsIFJFTEFUSVZFX1BPSU5UUywgUkVMQVRJVkVfUElQUywgUkVMQVRJVkVfQ1VSUkVOQ1ksIFJFTEFUSVZFX0JBTEFOQ0VfUEVSQ0VOVEFHRVxuICAgKi9cblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBzdG9wIGxpbWl0IHBlbmRpbmcgb3JkZXJcbiAgICogQHR5cGVkZWYge1BlbmRpbmdUcmFkZU9wdGlvbnN9IFN0b3BMaW1pdFBlbmRpbmdUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcGVuUHJpY2VCYXNlXSBkZWZpbmVkIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBvcGVuIHByaWNlIHJlbGF0aXZlIHRvIGZvciBPUkRFUl9NT0RJRllcbiAgICogYW5kIHBlbmRpbmcgb3JkZXIgcmVxdWVzdHMuIERlZmF1bHQgaXMgQ1VSUkVOVF9QUklDRSBmb3IgcGVuZGluZyBvcmRlcnMgb3IgU1RPUF9MSU1JVF9QUklDRSBmb3Igc3RvcCBsaW1pdCBvcmRlcnMuXG4gICAqIE9uZSBvZiBDVVJSRU5UX1BSSUNFLCBPUEVOX1BSSUNFLCBTVE9QX0xJTUlUX1BSSUNFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcExpbWl0UHJpY2VVbml0c10gc3RvcCBsaW1pdCBwcmljZSB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mXG4gICAqIHN0b3BMaW1pdFByaWNlIGZpZWxkIGlzIGEgZmluYWwgc3RvcCBsaW1pdCBwcmljZSB2YWx1ZS4gUkVMQVRJVkUqIG1lYW5zIHRoYXQgdGhlIHN0b3BMaW1pdFByaWNlIGZpZWxkIHZhbHVlXG4gICAqIGNvbnRhaW5zIHJlbGF0aXZlIHN0b3AgbGltaXQgcHJpY2UgZXhwcmVzc2VkIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50IGN1cnJlbmN5IG9yIGJhbGFuY2UgcGVyY2VudGFnZS5cbiAgICogRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gT25lIG9mIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSwgUkVMQVRJVkVfUE9JTlRTLCBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSxcbiAgICogUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBtb2RpZnlpbmcgb3JkZXJzXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1vZGlmeU9yZGVyT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge1RyYWlsaW5nU3RvcExvc3N9IFt0cmFpbGluZ1N0b3BMb3NzXSBkaXN0YW5jZSB0cmFpbGluZyBzdG9wIGxvc3MgY29uZmlndXJhdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N0b3BQcmljZUJhc2VdIGRlZmluZWQgdGhlIGJhc2UgcHJpY2UgdG8gY2FsY3VsYXRlIFNML1RQIHJlbGF0aXZlIHRvIGZvciAqX01PRElGWSBhbmQgcGVuZGluZ1xuICAgKiBvcmRlciByZXF1ZXN0cy4gU1RPUF9QUklDRSBtZWFucyB0aGUgU0wvVFAgaXMgcmVsYXRpdmUgdG8gcHJldmlvdXMgU0wvVFAgdmFsdWUuIERlZmF1bHQgaXMgT1BFTl9QUklDRSwgb25lIG9mXG4gICAqIENVUlJFTlRfUFJJQ0UsIE9QRU5fUFJJQ0UsIFNUT1BfUFJJQ0VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcGVuUHJpY2VVbml0c10gb3BlbiBwcmljZSB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mIG9wZW5QcmljZSBmaWVsZFxuICAgKiBpcyBhIGZpbmFsIG9wZW4gcHJpY2UgdmFsdWUuIFJFTEFUSVZFKiBtZWFucyB0aGF0IHRoZSBvcGVuUHJpY2UgZmllbGQgdmFsdWUgY29udGFpbnMgcmVsYXRpdmUgb3BlbiBwcmljZSBleHByZXNzZWRcbiAgICogZWl0aGVyIGluIHByaWNlLCBwb2ludHMsIHBpcHMsIGFjY291bnQgY3VycmVuY3kgb3IgYmFsYW5jZSBwZXJjZW50YWdlLiBEZWZhdWx0IGlzIEFCU09MVVRFX1BSSUNFLiBPbmUgb2ZcbiAgICogQUJTT0xVVEVfUFJJQ0UsIFJFTEFUSVZFX1BSSUNFLCBSRUxBVElWRV9QT0lOVFMsIFJFTEFUSVZFX1BJUFMsIFJFTEFUSVZFX0NVUlJFTkNZLCBSRUxBVElWRV9CQUxBTkNFX1BFUkNFTlRBR0VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcGVuUHJpY2VCYXNlXSBkZWZpbmVkIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBvcGVuIHByaWNlIHJlbGF0aXZlIHRvIGZvciBPUkRFUl9NT0RJRllcbiAgICogYW5kIHBlbmRpbmcgb3JkZXIgcmVxdWVzdHMuIERlZmF1bHQgaXMgQ1VSUkVOVF9QUklDRSBmb3IgcGVuZGluZyBvcmRlcnMgb3IgU1RPUF9MSU1JVF9QUklDRSBmb3Igc3RvcCBsaW1pdCBvcmRlcnMuXG4gICAqIE9uZSBvZiBDVVJSRU5UX1BSSUNFLCBPUEVOX1BSSUNFLCBTVE9QX0xJTUlUX1BSSUNFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcExpbWl0UHJpY2VVbml0c10gc3RvcCBsaW1pdCBwcmljZSB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mXG4gICAqIHN0b3BMaW1pdFByaWNlIGZpZWxkIGlzIGEgZmluYWwgc3RvcCBsaW1pdCBwcmljZSB2YWx1ZS4gUkVMQVRJVkUqIG1lYW5zIHRoYXQgdGhlIHN0b3BMaW1pdFByaWNlIGZpZWxkIHZhbHVlXG4gICAqIGNvbnRhaW5zIHJlbGF0aXZlIHN0b3AgbGltaXQgcHJpY2UgZXhwcmVzc2VkIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50IGN1cnJlbmN5IG9yIGJhbGFuY2UgcGVyY2VudGFnZS5cbiAgICogRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gT25lIG9mIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSwgUkVMQVRJVkVfUE9JTlRTLCBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSxcbiAgICogUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcExpbWl0UHJpY2VCYXNlXSBEZWZpbmVkIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBzdG9wIGxpbWl0IHByaWNlIHJlbGF0aXZlIHRvIGZvclxuICAgKiBPUkRFUl9NT0RJRlkgcmVxdWVzdHMuIE9uZSBvZiBDVVJSRU5UX1BSSUNFLCBTVE9QX0xJTUlUX1BSSUNFXG4gICAqL1xuXG4gIC8qKlxuICAgKiBQZW5kaW5nIG9yZGVyIGV4cGlyYXRpb24gc2V0dGluZ3NcbiAgICogQHR5cGVkZWYge09iamVjdH0gRXhwaXJhdGlvbk9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgcGVuZGluZyBvcmRlciBleHBpcmF0aW9uIHR5cGUuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL29yZGVycHJvcGVydGllcyNlbnVtX29yZGVyX3R5cGVfdGltZSBmb3IgdGhlIGxpc3Qgb2ZcbiAgICogcG9zc2libGUgb3B0aW9ucy4gTWV0YVRyYWRlcjQgcGxhdGZvcm0gc3VwcG9ydHMgb25seSBPUkRFUl9USU1FX1NQRUNJRklFRCBleHBpcmF0aW9uIHR5cGUuIE9uZSBvZiBPUkRFUl9USU1FX0dUQyxcbiAgICogT1JERVJfVElNRV9EQVksIE9SREVSX1RJTUVfU1BFQ0lGSUVELCBPUkRFUl9USU1FX1NQRUNJRklFRF9EQVlcbiAgICogQHByb3BlcnR5IHtEYXRlfSBbdGltZV0gb3B0aW9uYWwgcGVuZGluZyBvcmRlciBleHBpcmF0aW9uIHRpbWUuIElnbm9yZWQgaWYgZXhwaXJhdGlvbiB0eXBlIGlzIG5vdCBvbmUgb2ZcbiAgICogT1JERVJfVElNRV9EQVkgb3IgT1JERVJfVElNRV9TUEVDSUZJRURcbiAgICovXG5cbiAgLyoqXG4gICAqIFN0b3Agb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTdG9wT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gdmFsdWUgc3RvcCAoU0wgb3IgVFApIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1bml0cyBzdG9wIHVuaXRzLiBBQlNPTFVURV9QUklDRSBtZWFucyB0aGUgdGhhdCB0aGUgdmFsdWUgb2YgdmFsdWUgZmllbGQgaXMgYSBmaW5hbCBzdG9wIHZhbHVlLlxuICAgKiBSRUxBVElWRV8qIG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZpZWxkIHZhbHVlIGNvbnRhaW5zIHJlbGF0aXZlIHN0b3AgZXhwcmVzc2VkIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50XG4gICAqIGN1cnJlbmN5IG9yIGJhbGFuY2UgcGVyY2VudGFnZS4gRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gQWxsb3dlZCB2YWx1ZXMgYXJlIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSxcbiAgICogUkVMQVRJVkVfUE9JTlRTLCBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSwgUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFya2V0IGJ1eSBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge0NyZWF0ZU1hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVNYXJrZXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWScsIHN5bWJvbCwgdm9sdW1lfSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcmtldCBzZWxsIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7Q3JlYXRlTWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZU1hcmtldFNlbGxPcmRlcihzeW1ib2wsIHZvbHVtZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTEwnLCBzeW1ib2wsIHZvbHVtZX0sXG4gICAgICB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaW1pdCBidXkgb3JkZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBsaW1pdCBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1BlbmRpbmdUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY3JlYXRlTGltaXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZX0xJTUlUJywgc3ltYm9sLFxuICAgICAgdm9sdW1lLCBvcGVuUHJpY2V9LCB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaW1pdCBzZWxsIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgbGltaXQgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZUxpbWl0U2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMX0xJTUlUJywgc3ltYm9sLFxuICAgICAgdm9sdW1lLCBvcGVuUHJpY2V9LCB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdG9wIGJ1eSBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZVN0b3BCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZX1NUT1AnLCBzeW1ib2wsXG4gICAgICB2b2x1bWUsIG9wZW5QcmljZX0sIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0b3Agc2VsbCBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZVN0b3BTZWxsT3JkZXIoc3ltYm9sLCB2b2x1bWUsIG9wZW5QcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTExfU1RPUCcsIHN5bWJvbCxcbiAgICAgIHZvbHVtZSwgb3BlblByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RvcCBsaW1pdCBidXkgb3JkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdG9wTGltaXRQcmljZSB0aGUgbGltaXQgb3JkZXIgcHJpY2UgZm9yIHRoZSBzdG9wIGxpbWl0IG9yZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7U3RvcExpbWl0UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVTdG9wTGltaXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTGltaXRQcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWV9TVE9QX0xJTUlUJyxcbiAgICAgIHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RvcCBsaW1pdCBzZWxsIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgc3RvcCBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RvcExpbWl0UHJpY2UgdGhlIGxpbWl0IG9yZGVyIHByaWNlIGZvciB0aGUgc3RvcCBsaW1pdCBvcmRlclxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1N0b3BMaW1pdFBlbmRpbmdUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY3JlYXRlU3RvcExpbWl0U2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTF9TVE9QX0xJTUlUJyxcbiAgICAgIHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkIHRvIG1vZGlmeVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1RyYWlsaW5nU3RvcExvc3N9IFt0cmFpbGluZ1N0b3BMb3NzXSBkaXN0YW5jZSB0cmFpbGluZyBzdG9wIGxvc3MgY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3N0b3BQcmljZUJhc2VdIGRlZmluZXMgdGhlIGJhc2UgcHJpY2UgdG8gY2FsY3VsYXRlIFNMIHJlbGF0aXZlIHRvIGZvciBQT1NJVElPTl9NT0RJRlkgYW5kXG4gICAqIHBlbmRpbmcgb3JkZXIgcmVxdWVzdHMuIERlZmF1bHQgaXMgT1BFTl9QUklDRS4gT25lIG9mIENVUlJFTlRfUFJJQ0UsIE9QRU5fUFJJQ0UsIFNUT1BfUFJJQ0VcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIG1vZGlmeVBvc2l0aW9uKHBvc2l0aW9uSWQsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCB0cmFpbGluZ1N0b3BMb3NzLCBzdG9wUHJpY2VCYXNlKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX01PRElGWScsIHBvc2l0aW9uSWQsIHRyYWlsaW5nU3RvcExvc3MsIHN0b3BQcmljZUJhc2V9LFxuICAgICAgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgY2xvc2VzIGEgcG9zaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gbW9kaWZ5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgdm9sdW1lIHRvIGNsb3NlXG4gICAqIEBwYXJhbSB7TWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNsb3NlUG9zaXRpb25QYXJ0aWFsbHkocG9zaXRpb25JZCwgdm9sdW1lLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnUE9TSVRJT05fUEFSVElBTCcsIHBvc2l0aW9uSWQsXG4gICAgICB2b2x1bWV9LCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogRnVsbHkgY2xvc2VzIGEgcG9zaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gbW9kaWZ5XG4gICAqIEBwYXJhbSB7TWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNsb3NlUG9zaXRpb24ocG9zaXRpb25JZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX0NMT1NFX0lEJywgcG9zaXRpb25JZH0sXG4gICAgICBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogRnVsbHkgY2xvc2VzIGEgcG9zaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gY2xvc2UgYnkgb3Bwb3NpdGUgcG9zaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wcG9zaXRlUG9zaXRpb25JZCBvcHBvc2l0ZSBwb3NpdGlvbiBpZCB0byBjbG9zZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjbG9zZUJ5KHBvc2l0aW9uSWQsIG9wcG9zaXRlUG9zaXRpb25JZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX0NMT1NFX0JZJywgcG9zaXRpb25JZCxcbiAgICAgIGNsb3NlQnlQb3NpdGlvbklkOiBvcHBvc2l0ZVBvc2l0aW9uSWR9LCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHBvc2l0aW9ucyBieSBhIHN5bWJvbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjbG9zZVBvc2l0aW9uc0J5U3ltYm9sKHN5bWJvbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OU19DTE9TRV9TWU1CT0wnLCBzeW1ib2x9LFxuICAgICAgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgcGVuZGluZyBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JkZXJJZCBvcmRlciBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7TW9kaWZ5T3JkZXJPcHRpb25zfSBbb3B0aW9uc10gb3B0aW9uYWwgbW9kaWZ5IG9yZGVyIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIG1vZGlmeU9yZGVyKG9yZGVySWQsIG9wZW5QcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9NT0RJRlknLCBvcmRlcklkLCBvcGVuUHJpY2V9LFxuICAgICAgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcklkIG9yZGVyIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY2FuY2VsT3JkZXIob3JkZXJJZCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKHthY3Rpb25UeXBlOiAnT1JERVJfQ0FOQ0VMJywgb3JkZXJJZH0pO1xuICB9XG5cbiAgX3RyYWRlKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnRyYWRlKHRoaXMuX21ldGFBcGlDb25uZWN0aW9uLmFjY291bnQuaWQsIHJlcXVlc3QsXG4gICAgICB0aGlzLl9tZXRhQXBpQ29ubmVjdGlvbi5hcHBsaWNhdGlvbiwgdGhpcy5fbWV0YUFwaUNvbm5lY3Rpb24uYWNjb3VudC5yZWxpYWJpbGl0eSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBtYXJnaW4gcmVxdWlyZWQgdG8gb3BlbiBhIHRyYWRlIG9uIHRoZSBzcGVjaWZpZWQgdHJhZGluZyBhY2NvdW50XG4gICAqIEBwYXJhbSB7TWFyZ2luT3JkZXJ9IG9yZGVyIG9yZGVyIHRvIGNhbGN1bGF0ZSBtYXJnaW4gZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1hcmdpbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggbWFyZ2luIGNhbGN1bGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgY2FsY3VsYXRlTWFyZ2luKG9yZGVyKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmNhbGN1bGF0ZU1hcmdpbih0aGlzLl9tZXRhQXBpQ29ubmVjdGlvbi5hY2NvdW50LmlkLFxuICAgICAgdGhpcy5fbWV0YUFwaUNvbm5lY3Rpb24uYXBwbGljYXRpb24sIHRoaXMuX21ldGFBcGlDb25uZWN0aW9uLmFjY291bnQucmVsaWFiaWxpdHksIG9yZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgcmVmcmVzaCBhbmQgcmV0cmlldmVzIGxhdGVzdCBxdW90ZXMgZm9yIGEgc3Vic2V0IG9mIHN5bWJvbHMgdGhlIHRlcm1pbmFsIGlzIHN1YnNjcmliZWQgdG8uIE5vdGUsIHRoYXQgdGhpc1xuICAgKiBtZXRob2Qgd29ya3Mgc2VwYXJhdGVseSBmcm9tIHRoZSBzdHJlYW1lZCBkYXRhIChmb3Igc3RyZWFtaW5nIGNvbm5lY3Rpb24pLCBzbyB0aGUgcmVzcG9uc2UgbWF5IGJlIG9ic29sZXRlIGFscmVhZHksXG4gICAqIGlmIHNvbWUgdXBkYXRlcyBoYXBwZW4gZHVyaW5nIHRoZSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHN5bWJvbHMgcXVvdGUgc3ltYm9scyB0byByZWZyZXNoXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlZnJlc2hlZFF1b3Rlcz59IHF1b3RlcyB0aGF0IHdhcyBhY3R1YWxseSB1cGRhdGVkIChhIHN1YnNldCBvZiBzcGVjaWZpZWQgc3ltYm9scyksIGFuZCBzb21lIG9mXG4gICAqIGJhc2ljIGFjY291bnQgaW5mb3JtYXRpb25cbiAgICovXG4gIHJlZnJlc2hTeW1ib2xRdW90ZXMoc3ltYm9scykge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZWZyZXNoU3ltYm9sUXVvdGVzKHRoaXMuX21ldGFBcGlDb25uZWN0aW9uLmFjY291bnQuaWQsIHN5bWJvbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YUFwaSBhY2NvdW50XG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJBY2NvdW50fSBNZXRhQXBpIGFjY291bnRcbiAgICovXG4gIGdldCBhY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9tZXRhQXBpQ29ubmVjdGlvbi5hY2NvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29ubmVjdGlvbiBpbnN0YW5jZSBpZFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICovXG4gIGdldCBpbnN0YW5jZUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZUlkO1xuICB9XG5cbiAgX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpIHtcbiAgICBsZXQgdHJhZGUgPSB7fTtcbiAgICBpZiAodHlwZW9mIHN0b3BMb3NzID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhZGUuc3RvcExvc3MgPSBzdG9wTG9zcztcbiAgICB9IGVsc2UgaWYgKHN0b3BMb3NzKSB7XG4gICAgICB0cmFkZS5zdG9wTG9zcyA9IHN0b3BMb3NzLnZhbHVlO1xuICAgICAgdHJhZGUuc3RvcExvc3NVbml0cyA9IHN0b3BMb3NzLnVuaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRha2VQcm9maXQgPT09ICdudW1iZXInKSB7XG4gICAgICB0cmFkZS50YWtlUHJvZml0ID0gdGFrZVByb2ZpdDtcbiAgICB9IGVsc2UgaWYgKHRha2VQcm9maXQpIHtcbiAgICAgIHRyYWRlLnRha2VQcm9maXQgPSB0YWtlUHJvZml0LnZhbHVlO1xuICAgICAgdHJhZGUudGFrZVByb2ZpdFVuaXRzID0gdGFrZVByb2ZpdC51bml0cztcbiAgICB9XG4gICAgcmV0dXJuIHRyYWRlO1xuICB9XG5cbiAgX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCkge1xuICAgIGlmKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBjb25uZWN0aW9uIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQsIHBsZWFzZSBpbnZva2UgYXdhaXQgY29ubmVjdGlvbi5jb25uZWN0KCknKTtcbiAgICB9XG4gICAgaWYodGhpcy5fY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQsIHBsZWFzZSBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbicpO1xuICAgIH1cbiAgfVxuXG59XG4iXSwibmFtZXMiOlsiTWV0YUFwaUNvbm5lY3Rpb25JbnN0YW5jZSIsImNvbm5lY3QiLCJfb3BlbmVkIiwiY2xvc2UiLCJfY2xvc2VkIiwiY3JlYXRlTWFya2V0QnV5T3JkZXIiLCJzeW1ib2wiLCJ2b2x1bWUiLCJzdG9wTG9zcyIsInRha2VQcm9maXQiLCJvcHRpb25zIiwiX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlIiwiX3RyYWRlIiwiT2JqZWN0IiwiYXNzaWduIiwiYWN0aW9uVHlwZSIsIl9nZW5lcmF0ZVN0b3BPcHRpb25zIiwiY3JlYXRlTWFya2V0U2VsbE9yZGVyIiwiY3JlYXRlTGltaXRCdXlPcmRlciIsIm9wZW5QcmljZSIsImNyZWF0ZUxpbWl0U2VsbE9yZGVyIiwiY3JlYXRlU3RvcEJ1eU9yZGVyIiwiY3JlYXRlU3RvcFNlbGxPcmRlciIsImNyZWF0ZVN0b3BMaW1pdEJ1eU9yZGVyIiwic3RvcExpbWl0UHJpY2UiLCJjcmVhdGVTdG9wTGltaXRTZWxsT3JkZXIiLCJtb2RpZnlQb3NpdGlvbiIsInBvc2l0aW9uSWQiLCJ0cmFpbGluZ1N0b3BMb3NzIiwic3RvcFByaWNlQmFzZSIsImNsb3NlUG9zaXRpb25QYXJ0aWFsbHkiLCJjbG9zZVBvc2l0aW9uIiwiY2xvc2VCeSIsIm9wcG9zaXRlUG9zaXRpb25JZCIsImNsb3NlQnlQb3NpdGlvbklkIiwiY2xvc2VQb3NpdGlvbnNCeVN5bWJvbCIsIm1vZGlmeU9yZGVyIiwib3JkZXJJZCIsImNhbmNlbE9yZGVyIiwicmVxdWVzdCIsIl93ZWJzb2NrZXRDbGllbnQiLCJ0cmFkZSIsIl9tZXRhQXBpQ29ubmVjdGlvbiIsImFjY291bnQiLCJpZCIsImFwcGxpY2F0aW9uIiwicmVsaWFiaWxpdHkiLCJjYWxjdWxhdGVNYXJnaW4iLCJvcmRlciIsInJlZnJlc2hTeW1ib2xRdW90ZXMiLCJzeW1ib2xzIiwiaW5zdGFuY2VJZCIsIl9pbnN0YW5jZUlkIiwidmFsdWUiLCJzdG9wTG9zc1VuaXRzIiwidW5pdHMiLCJ0YWtlUHJvZml0VW5pdHMiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwid2Vic29ja2V0Q2xpZW50IiwibWV0YUFwaUNvbm5lY3Rpb24iLCJyYW5kb21zdHJpbmciLCJnZW5lcmF0ZSIsIl9sb2dnZXIiLCJMb2dnZXJNYW5hZ2VyIiwiZ2V0TG9nZ2VyIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztlQVNxQkE7OzsrRUFQYzsrREFDVDtxRUFDRDs7Ozs7O0FBS1YsSUFBQSxBQUFNQSw0QkFBTixNQUFNQTtJQWNuQjs7O0dBR0MsR0FDRCxNQUFNQyxVQUFVO1FBQ2QsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDakI7SUFFQTs7R0FFQyxHQUNELE1BQU1DLFFBQVE7UUFDWixJQUFJLENBQUNELE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0UsT0FBTyxHQUFHO0lBQ2pCO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkMsR0FFRDs7Ozs7OztHQU9DLEdBRUQ7Ozs7OztHQU1DLEdBRUQ7Ozs7Ozs7Ozs7Ozs7R0FhQyxHQUVEOzs7Ozs7Ozs7OztHQVdDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCQyxHQUVEOzs7Ozs7Ozs7R0FTQyxHQUVEOzs7Ozs7OztHQVFDLEdBRUQ7Ozs7Ozs7OztHQVNDLEdBQ0RDLHFCQUFxQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ3ZFLElBQUksQ0FBQ0Msd0JBQXdCO1FBQzdCLE9BQU8sSUFBSSxDQUFDQyxNQUFNLENBQUNDLE9BQU9DLE1BQU0sQ0FBQztZQUFDQyxZQUFZO1lBQWtCVDtZQUFRQztRQUFNLEdBQzVFLElBQUksQ0FBQ1Msb0JBQW9CLENBQUNSLFVBQVVDLGFBQWFDLFdBQVcsQ0FBQztJQUNqRTtJQUVBOzs7Ozs7Ozs7R0FTQyxHQUNETyxzQkFBc0JYLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRTtRQUN4RSxJQUFJLENBQUNDLHdCQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ0MsTUFBTSxDQUFD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