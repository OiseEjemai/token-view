'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import MetaApiWebsocketClient from '../clients/metaApi/metaApiWebsocket.client';
import LoggerManager from '../logger';
import randomstring from 'randomstring';
let MetaApiConnectionInstance = class MetaApiConnectionInstance {
    /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @return {Promise} promise resolving when the connection is opened
   */ connect() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._opened = true;
        })();
    }
    /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   */ close() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._opened = false;
            _this._closed = true;
        })();
    }
    /**
   * Common trade options
   * @typedef {Object} TradeOptions
   * @property {String} [comment] optional order comment. The sum of the line lengths of the comment and the
   * clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [clientId] optional client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {Number} [magic] optional magic (expert id) number. If not set default value specified in account entity
   * will be used.
   * @property {Number} [slippage] optional slippage in points. Should be greater or equal to zero. In not set,
   * default value specified in account entity will be used. Slippage is ignored if execution mode set to
   * SYMBOL_TRADE_EXECUTION_MARKET in symbol specification. Not used for close by orders.
   */ /**
   * Market trade options
   * @typedef {TradeOptions} MarketTradeOptions
   * @property {Array<String>} [fillingModes] optional allowed filling modes in the order of priority. Default is to
   * allow all filling modes and prefer ORDER_FILLING_FOK over ORDER_FILLING_IOC. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_filling for extra
   * explanation
   */ /**
   * Market trade options
   * @typedef {MarketTradeOptions} CreateMarketTradeOptions
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defines the base price to calculate SL/TP relative to for pending order
   * requests. Default is CURRENT_PRICE, one of CURRENT_PRICE
   */ /**
   * Pending order trade options
   * @typedef {TradeOptions} PendingTradeOptions
   * @property {ExpirationOptions} [expiration] optional pending order expiration settings. See Pending order expiration
   * settings section
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defined the base price to calculate SL/TP relative to for *_MODIFY and pending
   * order requests. STOP_PRICE means the SL/TP is relative to previous SL/TP value. Default is OPEN_PRICE, one of
   * CURRENT_PRICE, OPEN_PRICE
   * @property {String} [openPriceUnits] open price units. ABSOLUTE_PRICE means the that the value of openPrice field
   * is a final open price value. RELATIVE* means that the openPrice field value contains relative open price expressed
   * either in price, points, pips, account currency or balance percentage. Default is ABSOLUTE_PRICE. One of
   * ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   */ /**
   * Options for creating a stop limit pending order
   * @typedef {PendingTradeOptions} StopLimitPendingTradeOptions
   * @property {String} [openPriceBase] defined the base price to calculate open price relative to for ORDER_MODIFY
   * and pending order requests. Default is CURRENT_PRICE for pending orders or STOP_LIMIT_PRICE for stop limit orders.
   * One of CURRENT_PRICE, OPEN_PRICE, STOP_LIMIT_PRICE
   * @property {String} [stopLimitPriceUnits] stop limit price units. ABSOLUTE_PRICE means the that the value of
   * stopLimitPrice field is a final stop limit price value. RELATIVE* means that the stopLimitPrice field value
   * contains relative stop limit price expressed either in price, points, pips, account currency or balance percentage.
   * Default is ABSOLUTE_PRICE. One of ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY,
   * RELATIVE_BALANCE_PERCENTAGE
   */ /**
   * Options for modifying orders
   * @typedef {Object} ModifyOrderOptions
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defined the base price to calculate SL/TP relative to for *_MODIFY and pending
   * order requests. STOP_PRICE means the SL/TP is relative to previous SL/TP value. Default is OPEN_PRICE, one of
   * CURRENT_PRICE, OPEN_PRICE, STOP_PRICE
   * @property {String} [openPriceUnits] open price units. ABSOLUTE_PRICE means the that the value of openPrice field
   * is a final open price value. RELATIVE* means that the openPrice field value contains relative open price expressed
   * either in price, points, pips, account currency or balance percentage. Default is ABSOLUTE_PRICE. One of
   * ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   * @property {String} [openPriceBase] defined the base price to calculate open price relative to for ORDER_MODIFY
   * and pending order requests. Default is CURRENT_PRICE for pending orders or STOP_LIMIT_PRICE for stop limit orders.
   * One of CURRENT_PRICE, OPEN_PRICE, STOP_LIMIT_PRICE
   * @property {String} [stopLimitPriceUnits] stop limit price units. ABSOLUTE_PRICE means the that the value of
   * stopLimitPrice field is a final stop limit price value. RELATIVE* means that the stopLimitPrice field value
   * contains relative stop limit price expressed either in price, points, pips, account currency or balance percentage.
   * Default is ABSOLUTE_PRICE. One of ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY,
   * RELATIVE_BALANCE_PERCENTAGE
   * @property {String} [stopLimitPriceBase] Defined the base price to calculate stop limit price relative to for
   * ORDER_MODIFY requests. One of CURRENT_PRICE, STOP_LIMIT_PRICE
   */ /**
   * Pending order expiration settings
   * @typedef {Object} ExpirationOptions
   * @property {String} type pending order expiration type. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_time for the list of
   * possible options. MetaTrader4 platform supports only ORDER_TIME_SPECIFIED expiration type. One of ORDER_TIME_GTC,
   * ORDER_TIME_DAY, ORDER_TIME_SPECIFIED, ORDER_TIME_SPECIFIED_DAY
   * @property {Date} [time] optional pending order expiration time. Ignored if expiration type is not one of
   * ORDER_TIME_DAY or ORDER_TIME_SPECIFIED
   */ /**
   * Stop options
   * @typedef {Object} StopOptions
   * @property {number} value stop (SL or TP) value
   * @property {string} units stop units. ABSOLUTE_PRICE means the that the value of value field is a final stop value.
   * RELATIVE_* means that the value field value contains relative stop expressed either in price, points, pips, account
   * currency or balance percentage. Default is ABSOLUTE_PRICE. Allowed values are ABSOLUTE_PRICE, RELATIVE_PRICE,
   * RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   */ /**
   * Creates a market buy order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {CreateMarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createMarketBuyOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'ORDER_TYPE_BUY',
            symbol,
            volume
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a market sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {CreateMarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createMarketSellOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'ORDER_TYPE_SELL',
            symbol,
            volume
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a limit buy order
   * @param {String} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createLimitBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'ORDER_TYPE_BUY_LIMIT',
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a limit sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createLimitSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'ORDER_TYPE_SELL_LIMIT',
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop buy order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'ORDER_TYPE_BUY_STOP',
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'ORDER_TYPE_SELL_STOP',
            symbol,
            volume,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop limit buy order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {StopLimitPendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopLimitBuyOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'ORDER_TYPE_BUY_STOP_LIMIT',
            symbol,
            volume,
            openPrice,
            stopLimitPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Creates a stop limit sell order
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {StopLimitPendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ createStopLimitSellOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'ORDER_TYPE_SELL_STOP_LIMIT',
            symbol,
            volume,
            openPrice,
            stopLimitPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Modifies a position
   * @param {string} positionId position id to modify
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @param {String} [stopPriceBase] defines the base price to calculate SL relative to for POSITION_MODIFY and
   * pending order requests. Default is OPEN_PRICE. One of CURRENT_PRICE, OPEN_PRICE, STOP_PRICE
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ modifyPosition(positionId, stopLoss, takeProfit, trailingStopLoss, stopPriceBase) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'POSITION_MODIFY',
            positionId,
            trailingStopLoss,
            stopPriceBase
        }, this._generateStopOptions(stopLoss, takeProfit)));
    }
    /**
   * Partially closes a position
   * @param {string} positionId position id to modify
   * @param {number} volume volume to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closePositionPartially(positionId, volume, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'POSITION_PARTIAL',
            positionId,
            volume
        }, options || {}));
    }
    /**
   * Fully closes a position
   * @param {string} positionId position id to modify
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closePosition(positionId, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'POSITION_CLOSE_ID',
            positionId
        }, options || {}));
    }
    /**
   * Fully closes a position
   * @param {string} positionId position id to close by opposite position
   * @param {string} oppositePositionId opposite position id to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closeBy(positionId, oppositePositionId, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'POSITION_CLOSE_BY',
            positionId,
            closeByPositionId: oppositePositionId
        }, options || {}));
    }
    /**
   * Closes positions by a symbol
   * @param {string} symbol symbol to trade
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ closePositionsBySymbol(symbol, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'POSITIONS_CLOSE_SYMBOL',
            symbol
        }, options || {}));
    }
    /**
   * Modifies a pending order
   * @param {string} orderId order id (ticket number)
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {ModifyOrderOptions} [options] optional modify order options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ modifyOrder(orderId, openPrice, stopLoss, takeProfit, options = {}) {
        this._checkIsConnectionActive();
        return this._trade(Object.assign({
            actionType: 'ORDER_MODIFY',
            orderId,
            openPrice
        }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
    }
    /**
   * Cancels order
   * @param {string} orderId order id (ticket number)
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ cancelOrder(orderId) {
        this._checkIsConnectionActive();
        return this._trade({
            actionType: 'ORDER_CANCEL',
            orderId
        });
    }
    _trade(request) {
        return this._websocketClient.trade(this._metaApiConnection.account.id, request, this._metaApiConnection.application, this._metaApiConnection.account.reliability);
    }
    /**
   * Calculates margin required to open a trade on the specified trading account
   * @param {MarginOrder} order order to calculate margin for
   * @returns {Promise<Margin>} promise resolving with margin calculation result
   */ calculateMargin(order) {
        this._checkIsConnectionActive();
        return this._websocketClient.calculateMargin(this._metaApiConnection.account.id, this._metaApiConnection.application, this._metaApiConnection.account.reliability, order);
    }
    /**
   * Forces refresh and retrieves latest quotes for a subset of symbols the terminal is subscribed to. Note, that this
   * method works separately from the streamed data (for streaming connection), so the response may be obsolete already,
   * if some updates happen during the request
   * @param {string[]} symbols quote symbols to refresh
   * @returns {Promise<RefreshedQuotes>} quotes that was actually updated (a subset of specified symbols), and some of
   * basic account information
   */ refreshSymbolQuotes(symbols) {
        this._checkIsConnectionActive();
        return this._websocketClient.refreshSymbolQuotes(this._metaApiConnection.account.id, symbols);
    }
    /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */ get account() {
        return this._metaApiConnection.account;
    }
    /**
   * Returns connection instance id
   * @return {String} connection instance id
   */ get instanceId() {
        return this._instanceId;
    }
    _generateStopOptions(stopLoss, takeProfit) {
        let trade = {};
        if (typeof stopLoss === 'number') {
            trade.stopLoss = stopLoss;
        } else if (stopLoss) {
            trade.stopLoss = stopLoss.value;
            trade.stopLossUnits = stopLoss.units;
        }
        if (typeof takeProfit === 'number') {
            trade.takeProfit = takeProfit;
        } else if (takeProfit) {
            trade.takeProfit = takeProfit.value;
            trade.takeProfitUnits = takeProfit.units;
        }
        return trade;
    }
    _checkIsConnectionActive() {
        if (!this._opened) {
            throw new Error('This connection has not been initialized yet, please invoke await connection.connect()');
        }
        if (this._closed) {
            throw new Error('This connection has been closed, please create a new connection');
        }
    }
    /**
   * Constructs MetaApi MetaTrader Api connection instance
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {MetaApiConnection} metaApiConnection MetaApi connection to use
   */ constructor(websocketClient, metaApiConnection){
        this._websocketClient = websocketClient;
        this._metaApiConnection = metaApiConnection;
        this._instanceId = randomstring.generate(32);
        this._logger = LoggerManager.getLogger('MetaApiConnectionInstance');
    }
};
/**
 * Exposes MetaApi MetaTrader API connection instance to consumers
 */ export { MetaApiConnectionInstance as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBNZXRhQXBpV2Vic29ja2V0Q2xpZW50IGZyb20gJy4uL2NsaWVudHMvbWV0YUFwaS9tZXRhQXBpV2Vic29ja2V0LmNsaWVudCc7XG5pbXBvcnQgTG9nZ2VyTWFuYWdlciBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHJhbmRvbXN0cmluZyBmcm9tICdyYW5kb21zdHJpbmcnO1xuXG4vKipcbiAqIEV4cG9zZXMgTWV0YUFwaSBNZXRhVHJhZGVyIEFQSSBjb25uZWN0aW9uIGluc3RhbmNlIHRvIGNvbnN1bWVyc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBNZXRhQXBpIE1ldGFUcmFkZXIgQXBpIGNvbm5lY3Rpb24gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50fSB3ZWJzb2NrZXRDbGllbnQgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50XG4gICAqIEBwYXJhbSB7TWV0YUFwaUNvbm5lY3Rpb259IG1ldGFBcGlDb25uZWN0aW9uIE1ldGFBcGkgY29ubmVjdGlvbiB0byB1c2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdlYnNvY2tldENsaWVudCwgbWV0YUFwaUNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQgPSB3ZWJzb2NrZXRDbGllbnQ7XG4gICAgdGhpcy5fbWV0YUFwaUNvbm5lY3Rpb24gPSBtZXRhQXBpQ29ubmVjdGlvbjtcbiAgICB0aGlzLl9pbnN0YW5jZUlkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignTWV0YUFwaUNvbm5lY3Rpb25JbnN0YW5jZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBjb25uZWN0aW9uLiBDYW4gb25seSBiZSBjYWxsZWQgdGhlIGZpcnN0IHRpbWUsIG5leHQgY2FsbHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5lZFxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICB0aGlzLl9vcGVuZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi4gVGhlIGluc3RhbmNlIG9mIHRoZSBjbGFzcyBzaG91bGQgbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXIgdGhpcyBtZXRob2QgaXMgaW52b2tlZC5cbiAgICovXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHRoaXMuX29wZW5lZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDb21tb24gdHJhZGUgb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb21tZW50XSBvcHRpb25hbCBvcmRlciBjb21tZW50LiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlIGNvbW1lbnQgYW5kIHRoZVxuICAgKiBjbGllbnRJZCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NsaWVudElkXSBvcHRpb25hbCBjbGllbnQtYXNzaWduZWQgaWQuIFRoZSBpZCB2YWx1ZSBjYW4gYmUgYXNzaWduZWQgd2hlbiBzdWJtaXR0aW5nIGEgdHJhZGUgYW5kXG4gICAqIHdpbGwgYmUgcHJlc2VudCBvbiBwb3NpdGlvbiwgaGlzdG9yeSBvcmRlcnMgYW5kIGhpc3RvcnkgZGVhbHMgcmVsYXRlZCB0byB0aGUgdHJhZGUuIFlvdSBjYW4gdXNlIHRoaXMgZmllbGQgdG8gYmluZFxuICAgKiB5b3VyIHRyYWRlcyB0byBvYmplY3RzIGluIHlvdXIgYXBwbGljYXRpb24gYW5kIHRoZW4gdHJhY2sgdHJhZGUgcHJvZ3Jlc3MuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGVcbiAgICogY29tbWVudCBhbmQgdGhlIGNsaWVudElkIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWFnaWNdIG9wdGlvbmFsIG1hZ2ljIChleHBlcnQgaWQpIG51bWJlci4gSWYgbm90IHNldCBkZWZhdWx0IHZhbHVlIHNwZWNpZmllZCBpbiBhY2NvdW50IGVudGl0eVxuICAgKiB3aWxsIGJlIHVzZWQuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2xpcHBhZ2VdIG9wdGlvbmFsIHNsaXBwYWdlIGluIHBvaW50cy4gU2hvdWxkIGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gemVyby4gSW4gbm90IHNldCxcbiAgICogZGVmYXVsdCB2YWx1ZSBzcGVjaWZpZWQgaW4gYWNjb3VudCBlbnRpdHkgd2lsbCBiZSB1c2VkLiBTbGlwcGFnZSBpcyBpZ25vcmVkIGlmIGV4ZWN1dGlvbiBtb2RlIHNldCB0b1xuICAgKiBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX01BUktFVCBpbiBzeW1ib2wgc3BlY2lmaWNhdGlvbi4gTm90IHVzZWQgZm9yIGNsb3NlIGJ5IG9yZGVycy5cbiAgICovXG5cbiAgLyoqXG4gICAqIE1hcmtldCB0cmFkZSBvcHRpb25zXG4gICAqIEB0eXBlZGVmIHtUcmFkZU9wdGlvbnN9IE1hcmtldFRyYWRlT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge0FycmF5PFN0cmluZz59IFtmaWxsaW5nTW9kZXNdIG9wdGlvbmFsIGFsbG93ZWQgZmlsbGluZyBtb2RlcyBpbiB0aGUgb3JkZXIgb2YgcHJpb3JpdHkuIERlZmF1bHQgaXMgdG9cbiAgICogYWxsb3cgYWxsIGZpbGxpbmcgbW9kZXMgYW5kIHByZWZlciBPUkRFUl9GSUxMSU5HX0ZPSyBvdmVyIE9SREVSX0ZJTExJTkdfSU9DLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl90eXBlX2ZpbGxpbmcgZm9yIGV4dHJhXG4gICAqIGV4cGxhbmF0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNYXJrZXQgdHJhZGUgb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7TWFya2V0VHJhZGVPcHRpb25zfSBDcmVhdGVNYXJrZXRUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtUcmFpbGluZ1N0b3BMb3NzfSBbdHJhaWxpbmdTdG9wTG9zc10gZGlzdGFuY2UgdHJhaWxpbmcgc3RvcCBsb3NzIGNvbmZpZ3VyYXRpb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzdG9wUHJpY2VCYXNlXSBkZWZpbmVzIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBTTC9UUCByZWxhdGl2ZSB0byBmb3IgcGVuZGluZyBvcmRlclxuICAgKiByZXF1ZXN0cy4gRGVmYXVsdCBpcyBDVVJSRU5UX1BSSUNFLCBvbmUgb2YgQ1VSUkVOVF9QUklDRVxuICAgKi9cblxuICAvKipcbiAgICogUGVuZGluZyBvcmRlciB0cmFkZSBvcHRpb25zXG4gICAqIEB0eXBlZGVmIHtUcmFkZU9wdGlvbnN9IFBlbmRpbmdUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtFeHBpcmF0aW9uT3B0aW9uc30gW2V4cGlyYXRpb25dIG9wdGlvbmFsIHBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvbiBzZXR0aW5ncy4gU2VlIFBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvblxuICAgKiBzZXR0aW5ncyBzZWN0aW9uXG4gICAqIEBwcm9wZXJ0eSB7VHJhaWxpbmdTdG9wTG9zc30gW3RyYWlsaW5nU3RvcExvc3NdIGRpc3RhbmNlIHRyYWlsaW5nIHN0b3AgbG9zcyBjb25maWd1cmF0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcFByaWNlQmFzZV0gZGVmaW5lZCB0aGUgYmFzZSBwcmljZSB0byBjYWxjdWxhdGUgU0wvVFAgcmVsYXRpdmUgdG8gZm9yICpfTU9ESUZZIGFuZCBwZW5kaW5nXG4gICAqIG9yZGVyIHJlcXVlc3RzLiBTVE9QX1BSSUNFIG1lYW5zIHRoZSBTTC9UUCBpcyByZWxhdGl2ZSB0byBwcmV2aW91cyBTTC9UUCB2YWx1ZS4gRGVmYXVsdCBpcyBPUEVOX1BSSUNFLCBvbmUgb2ZcbiAgICogQ1VSUkVOVF9QUklDRSwgT1BFTl9QUklDRVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW29wZW5QcmljZVVuaXRzXSBvcGVuIHByaWNlIHVuaXRzLiBBQlNPTFVURV9QUklDRSBtZWFucyB0aGUgdGhhdCB0aGUgdmFsdWUgb2Ygb3BlblByaWNlIGZpZWxkXG4gICAqIGlzIGEgZmluYWwgb3BlbiBwcmljZSB2YWx1ZS4gUkVMQVRJVkUqIG1lYW5zIHRoYXQgdGhlIG9wZW5QcmljZSBmaWVsZCB2YWx1ZSBjb250YWlucyByZWxhdGl2ZSBvcGVuIHByaWNlIGV4cHJlc3NlZFxuICAgKiBlaXRoZXIgaW4gcHJpY2UsIHBvaW50cywgcGlwcywgYWNjb3VudCBjdXJyZW5jeSBvciBiYWxhbmNlIHBlcmNlbnRhZ2UuIERlZmF1bHQgaXMgQUJTT0xVVEVfUFJJQ0UuIE9uZSBvZlxuICAgKiBBQlNPTFVURV9QUklDRSwgUkVMQVRJVkVfUFJJQ0UsIFJFTEFUSVZFX1BPSU5UUywgUkVMQVRJVkVfUElQUywgUkVMQVRJVkVfQ1VSUkVOQ1ksIFJFTEFUSVZFX0JBTEFOQ0VfUEVSQ0VOVEFHRVxuICAgKi9cblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBzdG9wIGxpbWl0IHBlbmRpbmcgb3JkZXJcbiAgICogQHR5cGVkZWYge1BlbmRpbmdUcmFkZU9wdGlvbnN9IFN0b3BMaW1pdFBlbmRpbmdUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcGVuUHJpY2VCYXNlXSBkZWZpbmVkIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBvcGVuIHByaWNlIHJlbGF0aXZlIHRvIGZvciBPUkRFUl9NT0RJRllcbiAgICogYW5kIHBlbmRpbmcgb3JkZXIgcmVxdWVzdHMuIERlZmF1bHQgaXMgQ1VSUkVOVF9QUklDRSBmb3IgcGVuZGluZyBvcmRlcnMgb3IgU1RPUF9MSU1JVF9QUklDRSBmb3Igc3RvcCBsaW1pdCBvcmRlcnMuXG4gICAqIE9uZSBvZiBDVVJSRU5UX1BSSUNFLCBPUEVOX1BSSUNFLCBTVE9QX0xJTUlUX1BSSUNFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcExpbWl0UHJpY2VVbml0c10gc3RvcCBsaW1pdCBwcmljZSB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mXG4gICAqIHN0b3BMaW1pdFByaWNlIGZpZWxkIGlzIGEgZmluYWwgc3RvcCBsaW1pdCBwcmljZSB2YWx1ZS4gUkVMQVRJVkUqIG1lYW5zIHRoYXQgdGhlIHN0b3BMaW1pdFByaWNlIGZpZWxkIHZhbHVlXG4gICAqIGNvbnRhaW5zIHJlbGF0aXZlIHN0b3AgbGltaXQgcHJpY2UgZXhwcmVzc2VkIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50IGN1cnJlbmN5IG9yIGJhbGFuY2UgcGVyY2VudGFnZS5cbiAgICogRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gT25lIG9mIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSwgUkVMQVRJVkVfUE9JTlRTLCBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSxcbiAgICogUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBtb2RpZnlpbmcgb3JkZXJzXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1vZGlmeU9yZGVyT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge1RyYWlsaW5nU3RvcExvc3N9IFt0cmFpbGluZ1N0b3BMb3NzXSBkaXN0YW5jZSB0cmFpbGluZyBzdG9wIGxvc3MgY29uZmlndXJhdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N0b3BQcmljZUJhc2VdIGRlZmluZWQgdGhlIGJhc2UgcHJpY2UgdG8gY2FsY3VsYXRlIFNML1RQIHJlbGF0aXZlIHRvIGZvciAqX01PRElGWSBhbmQgcGVuZGluZ1xuICAgKiBvcmRlciByZXF1ZXN0cy4gU1RPUF9QUklDRSBtZWFucyB0aGUgU0wvVFAgaXMgcmVsYXRpdmUgdG8gcHJldmlvdXMgU0wvVFAgdmFsdWUuIERlZmF1bHQgaXMgT1BFTl9QUklDRSwgb25lIG9mXG4gICAqIENVUlJFTlRfUFJJQ0UsIE9QRU5fUFJJQ0UsIFNUT1BfUFJJQ0VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcGVuUHJpY2VVbml0c10gb3BlbiBwcmljZSB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mIG9wZW5QcmljZSBmaWVsZFxuICAgKiBpcyBhIGZpbmFsIG9wZW4gcHJpY2UgdmFsdWUuIFJFTEFUSVZFKiBtZWFucyB0aGF0IHRoZSBvcGVuUHJpY2UgZmllbGQgdmFsdWUgY29udGFpbnMgcmVsYXRpdmUgb3BlbiBwcmljZSBleHByZXNzZWRcbiAgICogZWl0aGVyIGluIHByaWNlLCBwb2ludHMsIHBpcHMsIGFjY291bnQgY3VycmVuY3kgb3IgYmFsYW5jZSBwZXJjZW50YWdlLiBEZWZhdWx0IGlzIEFCU09MVVRFX1BSSUNFLiBPbmUgb2ZcbiAgICogQUJTT0xVVEVfUFJJQ0UsIFJFTEFUSVZFX1BSSUNFLCBSRUxBVElWRV9QT0lOVFMsIFJFTEFUSVZFX1BJUFMsIFJFTEFUSVZFX0NVUlJFTkNZLCBSRUxBVElWRV9CQUxBTkNFX1BFUkNFTlRBR0VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcGVuUHJpY2VCYXNlXSBkZWZpbmVkIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBvcGVuIHByaWNlIHJlbGF0aXZlIHRvIGZvciBPUkRFUl9NT0RJRllcbiAgICogYW5kIHBlbmRpbmcgb3JkZXIgcmVxdWVzdHMuIERlZmF1bHQgaXMgQ1VSUkVOVF9QUklDRSBmb3IgcGVuZGluZyBvcmRlcnMgb3IgU1RPUF9MSU1JVF9QUklDRSBmb3Igc3RvcCBsaW1pdCBvcmRlcnMuXG4gICAqIE9uZSBvZiBDVVJSRU5UX1BSSUNFLCBPUEVOX1BSSUNFLCBTVE9QX0xJTUlUX1BSSUNFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcExpbWl0UHJpY2VVbml0c10gc3RvcCBsaW1pdCBwcmljZSB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mXG4gICAqIHN0b3BMaW1pdFByaWNlIGZpZWxkIGlzIGEgZmluYWwgc3RvcCBsaW1pdCBwcmljZSB2YWx1ZS4gUkVMQVRJVkUqIG1lYW5zIHRoYXQgdGhlIHN0b3BMaW1pdFByaWNlIGZpZWxkIHZhbHVlXG4gICAqIGNvbnRhaW5zIHJlbGF0aXZlIHN0b3AgbGltaXQgcHJpY2UgZXhwcmVzc2VkIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50IGN1cnJlbmN5IG9yIGJhbGFuY2UgcGVyY2VudGFnZS5cbiAgICogRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gT25lIG9mIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSwgUkVMQVRJVkVfUE9JTlRTLCBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSxcbiAgICogUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcExpbWl0UHJpY2VCYXNlXSBEZWZpbmVkIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBzdG9wIGxpbWl0IHByaWNlIHJlbGF0aXZlIHRvIGZvclxuICAgKiBPUkRFUl9NT0RJRlkgcmVxdWVzdHMuIE9uZSBvZiBDVVJSRU5UX1BSSUNFLCBTVE9QX0xJTUlUX1BSSUNFXG4gICAqL1xuXG4gIC8qKlxuICAgKiBQZW5kaW5nIG9yZGVyIGV4cGlyYXRpb24gc2V0dGluZ3NcbiAgICogQHR5cGVkZWYge09iamVjdH0gRXhwaXJhdGlvbk9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgcGVuZGluZyBvcmRlciBleHBpcmF0aW9uIHR5cGUuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL29yZGVycHJvcGVydGllcyNlbnVtX29yZGVyX3R5cGVfdGltZSBmb3IgdGhlIGxpc3Qgb2ZcbiAgICogcG9zc2libGUgb3B0aW9ucy4gTWV0YVRyYWRlcjQgcGxhdGZvcm0gc3VwcG9ydHMgb25seSBPUkRFUl9USU1FX1NQRUNJRklFRCBleHBpcmF0aW9uIHR5cGUuIE9uZSBvZiBPUkRFUl9USU1FX0dUQyxcbiAgICogT1JERVJfVElNRV9EQVksIE9SREVSX1RJTUVfU1BFQ0lGSUVELCBPUkRFUl9USU1FX1NQRUNJRklFRF9EQVlcbiAgICogQHByb3BlcnR5IHtEYXRlfSBbdGltZV0gb3B0aW9uYWwgcGVuZGluZyBvcmRlciBleHBpcmF0aW9uIHRpbWUuIElnbm9yZWQgaWYgZXhwaXJhdGlvbiB0eXBlIGlzIG5vdCBvbmUgb2ZcbiAgICogT1JERVJfVElNRV9EQVkgb3IgT1JERVJfVElNRV9TUEVDSUZJRURcbiAgICovXG5cbiAgLyoqXG4gICAqIFN0b3Agb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTdG9wT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gdmFsdWUgc3RvcCAoU0wgb3IgVFApIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1bml0cyBzdG9wIHVuaXRzLiBBQlNPTFVURV9QUklDRSBtZWFucyB0aGUgdGhhdCB0aGUgdmFsdWUgb2YgdmFsdWUgZmllbGQgaXMgYSBmaW5hbCBzdG9wIHZhbHVlLlxuICAgKiBSRUxBVElWRV8qIG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZpZWxkIHZhbHVlIGNvbnRhaW5zIHJlbGF0aXZlIHN0b3AgZXhwcmVzc2VkIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50XG4gICAqIGN1cnJlbmN5IG9yIGJhbGFuY2UgcGVyY2VudGFnZS4gRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gQWxsb3dlZCB2YWx1ZXMgYXJlIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSxcbiAgICogUkVMQVRJVkVfUE9JTlRTLCBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSwgUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFya2V0IGJ1eSBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge0NyZWF0ZU1hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVNYXJrZXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWScsIHN5bWJvbCwgdm9sdW1lfSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcmtldCBzZWxsIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7Q3JlYXRlTWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZU1hcmtldFNlbGxPcmRlcihzeW1ib2wsIHZvbHVtZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTEwnLCBzeW1ib2wsIHZvbHVtZX0sXG4gICAgICB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaW1pdCBidXkgb3JkZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBsaW1pdCBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1BlbmRpbmdUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY3JlYXRlTGltaXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZX0xJTUlUJywgc3ltYm9sLFxuICAgICAgdm9sdW1lLCBvcGVuUHJpY2V9LCB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaW1pdCBzZWxsIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgbGltaXQgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZUxpbWl0U2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMX0xJTUlUJywgc3ltYm9sLFxuICAgICAgdm9sdW1lLCBvcGVuUHJpY2V9LCB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdG9wIGJ1eSBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZVN0b3BCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZX1NUT1AnLCBzeW1ib2wsXG4gICAgICB2b2x1bWUsIG9wZW5QcmljZX0sIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0b3Agc2VsbCBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZVN0b3BTZWxsT3JkZXIoc3ltYm9sLCB2b2x1bWUsIG9wZW5QcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTExfU1RPUCcsIHN5bWJvbCxcbiAgICAgIHZvbHVtZSwgb3BlblByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RvcCBsaW1pdCBidXkgb3JkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdG9wTGltaXRQcmljZSB0aGUgbGltaXQgb3JkZXIgcHJpY2UgZm9yIHRoZSBzdG9wIGxpbWl0IG9yZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7U3RvcExpbWl0UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVTdG9wTGltaXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTGltaXRQcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWV9TVE9QX0xJTUlUJyxcbiAgICAgIHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RvcCBsaW1pdCBzZWxsIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgc3RvcCBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RvcExpbWl0UHJpY2UgdGhlIGxpbWl0IG9yZGVyIHByaWNlIGZvciB0aGUgc3RvcCBsaW1pdCBvcmRlclxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1N0b3BMaW1pdFBlbmRpbmdUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY3JlYXRlU3RvcExpbWl0U2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTF9TVE9QX0xJTUlUJyxcbiAgICAgIHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkIHRvIG1vZGlmeVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1RyYWlsaW5nU3RvcExvc3N9IFt0cmFpbGluZ1N0b3BMb3NzXSBkaXN0YW5jZSB0cmFpbGluZyBzdG9wIGxvc3MgY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3N0b3BQcmljZUJhc2VdIGRlZmluZXMgdGhlIGJhc2UgcHJpY2UgdG8gY2FsY3VsYXRlIFNMIHJlbGF0aXZlIHRvIGZvciBQT1NJVElPTl9NT0RJRlkgYW5kXG4gICAqIHBlbmRpbmcgb3JkZXIgcmVxdWVzdHMuIERlZmF1bHQgaXMgT1BFTl9QUklDRS4gT25lIG9mIENVUlJFTlRfUFJJQ0UsIE9QRU5fUFJJQ0UsIFNUT1BfUFJJQ0VcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIG1vZGlmeVBvc2l0aW9uKHBvc2l0aW9uSWQsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCB0cmFpbGluZ1N0b3BMb3NzLCBzdG9wUHJpY2VCYXNlKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX01PRElGWScsIHBvc2l0aW9uSWQsIHRyYWlsaW5nU3RvcExvc3MsIHN0b3BQcmljZUJhc2V9LFxuICAgICAgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgY2xvc2VzIGEgcG9zaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gbW9kaWZ5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgdm9sdW1lIHRvIGNsb3NlXG4gICAqIEBwYXJhbSB7TWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNsb3NlUG9zaXRpb25QYXJ0aWFsbHkocG9zaXRpb25JZCwgdm9sdW1lLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnUE9TSVRJT05fUEFSVElBTCcsIHBvc2l0aW9uSWQsXG4gICAgICB2b2x1bWV9LCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogRnVsbHkgY2xvc2VzIGEgcG9zaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gbW9kaWZ5XG4gICAqIEBwYXJhbSB7TWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNsb3NlUG9zaXRpb24ocG9zaXRpb25JZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX0NMT1NFX0lEJywgcG9zaXRpb25JZH0sXG4gICAgICBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogRnVsbHkgY2xvc2VzIGEgcG9zaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gY2xvc2UgYnkgb3Bwb3NpdGUgcG9zaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wcG9zaXRlUG9zaXRpb25JZCBvcHBvc2l0ZSBwb3NpdGlvbiBpZCB0byBjbG9zZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjbG9zZUJ5KHBvc2l0aW9uSWQsIG9wcG9zaXRlUG9zaXRpb25JZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX0NMT1NFX0JZJywgcG9zaXRpb25JZCxcbiAgICAgIGNsb3NlQnlQb3NpdGlvbklkOiBvcHBvc2l0ZVBvc2l0aW9uSWR9LCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHBvc2l0aW9ucyBieSBhIHN5bWJvbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjbG9zZVBvc2l0aW9uc0J5U3ltYm9sKHN5bWJvbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OU19DTE9TRV9TWU1CT0wnLCBzeW1ib2x9LFxuICAgICAgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgcGVuZGluZyBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JkZXJJZCBvcmRlciBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7TW9kaWZ5T3JkZXJPcHRpb25zfSBbb3B0aW9uc10gb3B0aW9uYWwgbW9kaWZ5IG9yZGVyIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIG1vZGlmeU9yZGVyKG9yZGVySWQsIG9wZW5QcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9NT0RJRlknLCBvcmRlcklkLCBvcGVuUHJpY2V9LFxuICAgICAgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcklkIG9yZGVyIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY2FuY2VsT3JkZXIob3JkZXJJZCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKHthY3Rpb25UeXBlOiAnT1JERVJfQ0FOQ0VMJywgb3JkZXJJZH0pO1xuICB9XG5cbiAgX3RyYWRlKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnRyYWRlKHRoaXMuX21ldGFBcGlDb25uZWN0aW9uLmFjY291bnQuaWQsIHJlcXVlc3QsXG4gICAgICB0aGlzLl9tZXRhQXBpQ29ubmVjdGlvbi5hcHBsaWNhdGlvbiwgdGhpcy5fbWV0YUFwaUNvbm5lY3Rpb24uYWNjb3VudC5yZWxpYWJpbGl0eSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBtYXJnaW4gcmVxdWlyZWQgdG8gb3BlbiBhIHRyYWRlIG9uIHRoZSBzcGVjaWZpZWQgdHJhZGluZyBhY2NvdW50XG4gICAqIEBwYXJhbSB7TWFyZ2luT3JkZXJ9IG9yZGVyIG9yZGVyIHRvIGNhbGN1bGF0ZSBtYXJnaW4gZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1hcmdpbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggbWFyZ2luIGNhbGN1bGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgY2FsY3VsYXRlTWFyZ2luKG9yZGVyKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmNhbGN1bGF0ZU1hcmdpbih0aGlzLl9tZXRhQXBpQ29ubmVjdGlvbi5hY2NvdW50LmlkLFxuICAgICAgdGhpcy5fbWV0YUFwaUNvbm5lY3Rpb24uYXBwbGljYXRpb24sIHRoaXMuX21ldGFBcGlDb25uZWN0aW9uLmFjY291bnQucmVsaWFiaWxpdHksIG9yZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgcmVmcmVzaCBhbmQgcmV0cmlldmVzIGxhdGVzdCBxdW90ZXMgZm9yIGEgc3Vic2V0IG9mIHN5bWJvbHMgdGhlIHRlcm1pbmFsIGlzIHN1YnNjcmliZWQgdG8uIE5vdGUsIHRoYXQgdGhpc1xuICAgKiBtZXRob2Qgd29ya3Mgc2VwYXJhdGVseSBmcm9tIHRoZSBzdHJlYW1lZCBkYXRhIChmb3Igc3RyZWFtaW5nIGNvbm5lY3Rpb24pLCBzbyB0aGUgcmVzcG9uc2UgbWF5IGJlIG9ic29sZXRlIGFscmVhZHksXG4gICAqIGlmIHNvbWUgdXBkYXRlcyBoYXBwZW4gZHVyaW5nIHRoZSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHN5bWJvbHMgcXVvdGUgc3ltYm9scyB0byByZWZyZXNoXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlZnJlc2hlZFF1b3Rlcz59IHF1b3RlcyB0aGF0IHdhcyBhY3R1YWxseSB1cGRhdGVkIChhIHN1YnNldCBvZiBzcGVjaWZpZWQgc3ltYm9scyksIGFuZCBzb21lIG9mXG4gICAqIGJhc2ljIGFjY291bnQgaW5mb3JtYXRpb25cbiAgICovXG4gIHJlZnJlc2hTeW1ib2xRdW90ZXMoc3ltYm9scykge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZWZyZXNoU3ltYm9sUXVvdGVzKHRoaXMuX21ldGFBcGlDb25uZWN0aW9uLmFjY291bnQuaWQsIHN5bWJvbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YUFwaSBhY2NvdW50XG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJBY2NvdW50fSBNZXRhQXBpIGFjY291bnRcbiAgICovXG4gIGdldCBhY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9tZXRhQXBpQ29ubmVjdGlvbi5hY2NvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29ubmVjdGlvbiBpbnN0YW5jZSBpZFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICovXG4gIGdldCBpbnN0YW5jZUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZUlkO1xuICB9XG5cbiAgX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpIHtcbiAgICBsZXQgdHJhZGUgPSB7fTtcbiAgICBpZiAodHlwZW9mIHN0b3BMb3NzID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhZGUuc3RvcExvc3MgPSBzdG9wTG9zcztcbiAgICB9IGVsc2UgaWYgKHN0b3BMb3NzKSB7XG4gICAgICB0cmFkZS5zdG9wTG9zcyA9IHN0b3BMb3NzLnZhbHVlO1xuICAgICAgdHJhZGUuc3RvcExvc3NVbml0cyA9IHN0b3BMb3NzLnVuaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRha2VQcm9maXQgPT09ICdudW1iZXInKSB7XG4gICAgICB0cmFkZS50YWtlUHJvZml0ID0gdGFrZVByb2ZpdDtcbiAgICB9IGVsc2UgaWYgKHRha2VQcm9maXQpIHtcbiAgICAgIHRyYWRlLnRha2VQcm9maXQgPSB0YWtlUHJvZml0LnZhbHVlO1xuICAgICAgdHJhZGUudGFrZVByb2ZpdFVuaXRzID0gdGFrZVByb2ZpdC51bml0cztcbiAgICB9XG4gICAgcmV0dXJuIHRyYWRlO1xuICB9XG5cbiAgX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCkge1xuICAgIGlmKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBjb25uZWN0aW9uIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQsIHBsZWFzZSBpbnZva2UgYXdhaXQgY29ubmVjdGlvbi5jb25uZWN0KCknKTtcbiAgICB9XG4gICAgaWYodGhpcy5fY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQsIHBsZWFzZSBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbicpO1xuICAgIH1cbiAgfVxuXG59XG4iXSwibmFtZXMiOlsiTWV0YUFwaVdlYnNvY2tldENsaWVudCIsIkxvZ2dlck1hbmFnZXIiLCJyYW5kb21zdHJpbmciLCJNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlIiwiY29ubmVjdCIsIl9vcGVuZWQiLCJjbG9zZSIsIl9jbG9zZWQiLCJjcmVhdGVNYXJrZXRCdXlPcmRlciIsInN5bWJvbCIsInZvbHVtZSIsInN0b3BMb3NzIiwidGFrZVByb2ZpdCIsIm9wdGlvbnMiLCJfY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUiLCJfdHJhZGUiLCJPYmplY3QiLCJhc3NpZ24iLCJhY3Rpb25UeXBlIiwiX2dlbmVyYXRlU3RvcE9wdGlvbnMiLCJjcmVhdGVNYXJrZXRTZWxsT3JkZXIiLCJjcmVhdGVMaW1pdEJ1eU9yZGVyIiwib3BlblByaWNlIiwiY3JlYXRlTGltaXRTZWxsT3JkZXIiLCJjcmVhdGVTdG9wQnV5T3JkZXIiLCJjcmVhdGVTdG9wU2VsbE9yZGVyIiwiY3JlYXRlU3RvcExpbWl0QnV5T3JkZXIiLCJzdG9wTGltaXRQcmljZSIsImNyZWF0ZVN0b3BMaW1pdFNlbGxPcmRlciIsIm1vZGlmeVBvc2l0aW9uIiwicG9zaXRpb25JZCIsInRyYWlsaW5nU3RvcExvc3MiLCJzdG9wUHJpY2VCYXNlIiwiY2xvc2VQb3NpdGlvblBhcnRpYWxseSIsImNsb3NlUG9zaXRpb24iLCJjbG9zZUJ5Iiwib3Bwb3NpdGVQb3NpdGlvbklkIiwiY2xvc2VCeVBvc2l0aW9uSWQiLCJjbG9zZVBvc2l0aW9uc0J5U3ltYm9sIiwibW9kaWZ5T3JkZXIiLCJvcmRlcklkIiwiY2FuY2VsT3JkZXIiLCJyZXF1ZXN0IiwiX3dlYnNvY2tldENsaWVudCIsInRyYWRlIiwiX21ldGFBcGlDb25uZWN0aW9uIiwiYWNjb3VudCIsImlkIiwiYXBwbGljYXRpb24iLCJyZWxpYWJpbGl0eSIsImNhbGN1bGF0ZU1hcmdpbiIsIm9yZGVyIiwicmVmcmVzaFN5bWJvbFF1b3RlcyIsInN5bWJvbHMiLCJpbnN0YW5jZUlkIiwiX2luc3RhbmNlSWQiLCJ2YWx1ZSIsInN0b3BMb3NzVW5pdHMiLCJ1bml0cyIsInRha2VQcm9maXRVbml0cyIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJ3ZWJzb2NrZXRDbGllbnQiLCJtZXRhQXBpQ29ubmVjdGlvbiIsImdlbmVyYXRlIiwiX2xvZ2dlciIsImdldExvZ2dlciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLE9BQU9BLDRCQUE0Qiw2Q0FBNkM7QUFDaEYsT0FBT0MsbUJBQW1CLFlBQVk7QUFDdEMsT0FBT0Msa0JBQWtCLGVBQWU7QUFLekIsSUFBQSxBQUFNQyw0QkFBTixNQUFNQTtJQWNuQjs7O0dBR0MsR0FDRCxBQUFNQzs7ZUFBTixvQkFBQTtZQUNFLE1BQUtDLE9BQU8sR0FBRztRQUNqQjs7SUFFQTs7R0FFQyxHQUNELEFBQU1DOztlQUFOLG9CQUFBO1lBQ0UsTUFBS0QsT0FBTyxHQUFHO1lBQ2YsTUFBS0UsT0FBTyxHQUFHO1FBQ2pCOztJQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JDLEdBRUQ7Ozs7Ozs7R0FPQyxHQUVEOzs7Ozs7R0FNQyxHQUVEOzs7Ozs7Ozs7Ozs7O0dBYUMsR0FFRDs7Ozs7Ozs7Ozs7R0FXQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQkMsR0FFRDs7Ozs7Ozs7O0dBU0MsR0FFRDs7Ozs7Ozs7R0FRQyxHQUVEOzs7Ozs7Ozs7R0FTQyxHQUNEQyxxQkFBcUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRTtRQUN2RSxJQUFJLENBQUNDLHdCQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPQyxNQUFNLENBQUM7WUFBQ0MsWUFBWTtZQUFrQlQ7WUFBUUM7UUFBTSxHQUM1RSxJQUFJLENBQUNTLG9CQUFvQixDQUFDUixVQUFVQyxhQUFhQyxXQUFXLENBQUM7SUFDakU7SUFFQTs7Ozs7Ozs7O0dBU0MsR0FDRE8sc0JBQXNCWCxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxF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